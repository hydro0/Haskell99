
==================== FINAL INTERFACE ====================
2017-12-24 18:40:00.69197 UTC

interface main@main:Main 8002
  interface hash: d89a50143ef88999e1a01d7bac4f8bd7
  ABI hash: a4dc5d45c37a10abb31d3cb810cf873e
  export-list hash: a5349420a4c039572f6a2e8e698a3076
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 8c004973c479508f078a0ca0e4fd2f67
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.combinations
  Main.compress
  Main.decode_mod
  Main.dropEvery
  Main.dupl
  Main.elementAt
  Main.encode
  Main.encode_mod
  Main.fact
  Main.insertAt
  Main.isPalindrome
  Main.main
  Main.myButLast
  Main.myFlatten
  Main.myLast
  Main.myLength
  Main.myReverse
  Main.pack
  Main.printResults
  Main.range
  Main.remove
  Main.repli
  Main.rndElem
  Main.rndPermutation
  Main.rnd_select
  Main.rnd_select_i
  Main.rotate
  Main.solve
  Main.solveWithCounter
  Main.split
  Main.Ext{Main.Multiple Main.Single}
  Main.NestedList{Main.Elem Main.List}
module dependencies: AddingReversedNumbers BTSFactorial
                     LifeUniverseEverything NextPalindrome PrimeGenerator RPN
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog*
                      time-1.6.0.1@time-1.6.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO c9de64c5f5407c4cf1c52500c4d15200
import  -/  base-4.9.1.0:Text.Read 75c59863e882ebaec4532e9465e2ee9b
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  integer-gmp-1.0.0.1:GHC.Integer.Type 318df275d77dcdb18e0006d8d7870c2a
import  -/  AddingReversedNumbers 6137c02bc657151b1f26a01446e78505
  exports: 87b8b0729bac3cac902761686177259a
import  -/  BTSFactorial 84a535de938a27dea1bbc06d65a607b9
  exports: 417a29e3c6a7671decf6ac120166d758
import  -/  LifeUniverseEverything d5d710a1c24d40f636b6ae2c40f2b300
  exports: 79c1062d0367aac31ac113957f4c4f48
import  -/  NextPalindrome 027f9af3f348631aea683d339e5d56be
  exports: 461f94576370408b1c23d13f5e612a2c
import  -/  PrimeGenerator b40bd086bad70f264b8ced545dda7682
  exports: 8ddf525f9c611a8b8fbf6acac5c43572
import  -/  RPN 361416fe8db3265c83fc70c491bf9b37
  exports: ad75336e76ffeae2a17c8344dd586846
import  -/  random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog:System.Random cc3ef358c669b194cf9fe94db6f2430f
ab9bedec3aa6c3816fa804df64e61e58
  $fShowExt :: GHC.Show.Show a => GHC.Show.Show (Main.Ext a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Main.Ext a)
                  (Main.$fShowExt_$cshowsPrec @ a $dShow)
                  (Main.$fShowExt_$cshow @ a $dShow)
                  (Main.$fShowExt_$cshowList @ a $dShow) -}
2476adad0b1c4ca95f50e889a3e75d39
  $fShowExt1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
4ee1e102415f33fbd98f807e08327ef5
  $fShowExt2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Single "#) -}
924d954f7dd68f580e31f2c357b11061
  $fShowExt3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
7a75e4b0b97ceb2ca85b620dc572bc43
  $fShowExt4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Multiple "#) -}
83d6bcd1abf4df24a647bba00caea196
  $fShowExt5 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows4
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ab9bedec3aa6c3816fa804df64e61e58
  $fShowExt_$cshow ::
    GHC.Show.Show a => Main.Ext a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,1*U>,
     Unfolding: (\ @ a ($dShow :: GHC.Show.Show a) (x :: Main.Ext a) ->
                 case x of wild {
                   Main.Multiple b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Main.$fShowExt4
                        (case b1 of ww { (,) ww1 ww2 ->
                         GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows7
                           (case ww1 of ww4 { GHC.Types.I# ww3 ->
                            case GHC.Show.$wshowSignedInt
                                   0#
                                   ww3
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.shows5
                                      (GHC.Show.$fShow(,)_$sgo
                                         Main.$fShowExt5
                                         (GHC.Show.showsPrec @ a $dShow GHC.Show.shows22 ww2)
                                         (GHC.Types.[] @ GHC.Show.ShowS))) of ww5 { (#,#) ww6 ww7 ->
                            GHC.Types.: @ GHC.Types.Char ww6 ww7 } }) })
                   Main.Single b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Main.$fShowExt2
                        (GHC.Show.showsPrec
                           @ a
                           $dShow
                           Main.$fShowExt3
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
ab9bedec3aa6c3816fa804df64e61e58
  $fShowExt_$cshowList ::
    GHC.Show.Show a => [Main.Ext a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Main.Ext a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Ext a)
                   (Main.$fShowExt_$cshowsPrec @ a $dShow Main.$fShowExt1)
                   eta
                   eta1) -}
ab9bedec3aa6c3816fa804df64e61e58
  $fShowExt_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Main.Ext a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Main.Ext a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Main.$w$cshowsPrec @ a w ww1 w2 }) -}
d63c6e902678bee5b36d56ff4bfddfe2
  $tc'Elem :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17327168035761514749##
                   2325504556886121138##
                   Main.$trModule
                   Main.$tc'Elem1) -}
3c11f571b1c04145eaa95a536e147b32
  $tc'Elem1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Elem"#) -}
46522d52751dc50649257d119071f56c
  $tc'List :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17414508030287696193##
                   1475919201417240795##
                   Main.$trModule
                   Main.$tc'List1) -}
5cd3b142e25354d03ec7218b9a7bf692
  $tc'List1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'List"#) -}
17804e81547f7c90602f2c896e1ce6c3
  $tc'Multiple :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4657229928005733577##
                   1981937757250795924##
                   Main.$trModule
                   Main.$tc'Multiple1) -}
b78c42c8b5103bb106d3e57546fb067b
  $tc'Multiple1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Multiple"#) -}
27878eafe3fb39da72746fbf7268a518
  $tc'Single :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   757164489821052818##
                   13788531866546215356##
                   Main.$trModule
                   Main.$tc'Single1) -}
339c99460c9f65284efceeab557be636
  $tc'Single1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Single"#) -}
36baf676acfd0b41ee8246c20bff7012
  $tcExt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6441824245102875745##
                   5469355464743097422##
                   Main.$trModule
                   Main.$tcExt1) -}
fde159b88ed2b328151aeda1e117aa6a
  $tcExt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Ext"#) -}
2cab99f781d3a103295f1513dfbba504
  $tcNestedList :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9067267851135806687##
                   10246202200427909738##
                   Main.$trModule
                   Main.$tcNestedList1) -}
b00d8499870a8efe51b16603ed6ecd91
  $tcNestedList1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "NestedList"#) -}
d6831ef04cb9301b090dfae6f7bb7ec7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule2 Main.$trModule1) -}
847d9fc3b8e6f0b424199f36b4999bb2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Main"#) -}
24ef6042833e75ffd7aa98b83ecca98d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
ab9bedec3aa6c3816fa804df64e61e58
  $w$cshowsPrec ::
    GHC.Show.Show a => GHC.Prim.Int# -> Main.Ext a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Main.Ext a) ->
                 case w1 of wild {
                   Main.Multiple b1
                   -> let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ (x :: GHC.Base.String) ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Main.$fShowExt4
                            (case b1 of ww1 { (,) ww2 ww3 ->
                             GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.shows7
                               (case ww2 of ww4 { GHC.Types.I# ww5 ->
                                case GHC.Show.$wshowSignedInt
                                       0#
                                       ww5
                                       (GHC.Types.:
                                          @ GHC.Types.Char
                                          GHC.Show.shows5
                                          (GHC.Show.$fShow(,)_$sgo
                                             (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)
                                             (GHC.Show.showsPrec @ a w GHC.Show.shows22 ww3)
                                             (GHC.Types.[]
                                                @ GHC.Show.ShowS))) of ww6 { (#,#) ww7 ww8 ->
                                GHC.Types.: @ GHC.Types.Char ww7 ww8 } }) })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }
                   Main.Single b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a w Main.$fShowExt3 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Main.$fShowExt2 (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Main.$fShowExt2
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) } }) -}
d95f4734ebea8afed387b3a2d5fc0984
  $welementAt :: [a] -> GHC.Prim.Int# -> a
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0] -}
3d5a558083ae6ad799190c5244b4213d
  $winsertAt :: a -> [a] -> GHC.Prim.Int# -> (# a, [a] #)
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
1c3d3f59988852fd6667248d18095a6a
  $wmyLength :: [a] -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
d45dbd5790548c398051d2da6fdd0839
  $wpoly_helper :: [a] -> GHC.Types.Int -> (# [a], [a] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)>,
     Inline: [0] -}
7d6ddc571cfb8d57dc0816cdd55989ea
  $wprintResults ::
    (GHC.Base.String -> GHC.Base.String)
    -> GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,C(U)><S,1*U><S,U>, Inline: [0] -}
84643437b69953677bf8766a36cbf547
  $wrange ::
    GHC.Prim.Int#
    -> GHC.Prim.Int# -> (# GHC.Types.Int, [GHC.Types.Int] #)
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0] -}
d6faf55e55ed67cd38e207a37c90075f
  $wremove :: [a] -> GHC.Types.Int -> (# GHC.Base.Maybe a, [a] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(1*U)>,
     Inline: [0] -}
4a39622e3dda870c9af390ec104e3a23
  $wsolve ::
    GHC.Base.String -> (# GHC.Types.Char, [GHC.Types.Char] #)
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Base.String) ->
                 case Text.Read.readEither6
                        @ GHC.Integer.Type.Integer
                        (Text.ParserCombinators.ReadP.run
                           @ GHC.Integer.Type.Integer
                           Main.solve3
                           w) of wild {
                   []
                   -> case Main.solve2
                      ret_ty (# GHC.Types.Char, [GHC.Types.Char] #)
                      of {}
                   : x ds
                   -> case ds of wild1 {
                        []
                        -> GHC.Show.$w$cshowsPrec1
                             0#
                             (Main.fact x)
                             (GHC.Types.[] @ GHC.Types.Char)
                        : ipv ipv1
                        -> case Main.solve1
                           ret_ty (# GHC.Types.Char, [GHC.Types.Char] #)
                           of {} } }) -}
ab9bedec3aa6c3816fa804df64e61e58
  data Ext a = Multiple (GHC.Types.Int, a) | Single a
3c2dafe73f215d790e902b1f4228cf87
  data NestedList a = Elem a | List [Main.NestedList a]
65751f7e039387692c15914115af56ef
  combinations :: GHC.Types.Int -> [a] -> [[a]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><L,1*U>,
     Unfolding: (\ @ a (n :: GHC.Types.Int) (xs :: [a]) ->
                 GHC.List.filter
                   @ [a]
                   (\ (x :: [a]) ->
                    case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                    case n of wild1 { GHC.Types.I# y ->
                    GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# ww2 y) } })
                   (GHC.Types.:
                      @ [a]
                      (GHC.Types.[] @ a)
                      (Data.OldList.nonEmptySubsequences @ a xs))) -}
6a17a30c8e83c1dac0add572c3e41199
  compress :: GHC.Classes.Eq a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><S,1*U> -}
1f153303bf114efd9f28f14b296564b2
  decode_mod :: [Main.Ext a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (xs :: [Main.Ext a]) ->
                 Main.decode_mod1 @ a xs) -}
7cab509f03a0fccdac86c8b26664e54e
  decode_mod1 :: [Main.Ext a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
46c5d70f0ef28faf9d95d6d1f2293167
  dropEvery :: [a] -> GHC.Types.Int -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U)>,
     Unfolding: (\ @ a (xs :: [a]) (n :: GHC.Types.Int) ->
                 letrec {
                   dropEvery' :: [a] -> GHC.Types.Int -> [a]
                     {- Arity: 2, Strictness: <S,1*U><L,1*U(1*U)> -}
                   = \ (ds :: [a]) (ds1 :: GHC.Types.Int) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ a
                       : x xs1
                       -> case ds1 of wild1 { GHC.Types.I# ds2 ->
                          case ds2 of ds3 {
                            DEFAULT
                            -> GHC.Types.:
                                 @ a
                                 x
                                 (dropEvery' xs1 (GHC.Types.I# (GHC.Prim.-# ds3 1#)))
                            1# -> dropEvery' xs1 n } } }
                 } in
                 dropEvery' xs n) -}
e09806fa5fa10d1b09040be9610d7dec
  dupl :: [a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
30acf1bb1ef482aa61254db56c1bb56e
  elementAt :: [a] -> GHC.Types.Int -> a
  {- Arity: 2, Strictness: <S,1*U><S(S),1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: [a]) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Main.$welementAt @ a w ww1 }) -}
0e537a6667a4b2492d681561a39ebf17
  encode :: GHC.Classes.Eq a => [a] -> [(GHC.Types.Int, a)]
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (xs :: [a]) ->
                 GHC.Base.build
                   @ (GHC.Types.Int, a)
                   (\ @ b1
                      (c :: (GHC.Types.Int, a) -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [a]
                      @ b1
                      (GHC.Base.mapFB
                         @ (GHC.Types.Int, a)
                         @ b1
                         @ [a]
                         c
                         (Main.encode1 @ a))
                      n
                      (Main.pack @ a $dEq xs))) -}
77ff30713f57f5a38fe5fb8d9e71b13e
  encode1 :: [a] -> (GHC.Types.Int, a)
  {- Arity: 1, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (xs :: [a]) ->
                 (case GHC.List.$wlenAcc @ a xs 0# of ww2 { DEFAULT ->
                  GHC.Types.I# ww2 },
                  GHC.List.head @ a xs)) -}
ede33f3feb6880e23e5711da96c85805
  encode_mod :: GHC.Classes.Eq a => [a] -> [Main.Ext a]
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A)><S,1*U>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (xs :: [a]) ->
                 GHC.Base.map
                   @ [a]
                   @ (Main.Ext a)
                   (Main.encode_mod1 @ a)
                   (Main.pack @ a $dEq xs)) -}
ff18cf541bd900bf5eef507ad52fe226
  encode_mod1 :: [a] -> Main.Ext a
  {- Arity: 1,
     Unfolding: (\ @ a (x :: [a]) ->
                 case GHC.List.$wlenAcc @ a x 0# of ww2 {
                   DEFAULT
                   -> Main.Multiple @ a (GHC.Types.I# ww2, GHC.List.head @ a x)
                   1# -> Main.Single @ a (GHC.List.head @ a x) }) -}
001ca884a6798c7eed517f005940b44b
  fact :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,U> -}
947271d99ee25de1a4a66f45fe8cecf3
  insertAt :: a -> [a] -> GHC.Types.Int -> [a]
  {- Arity: 3, Strictness: <L,U><L,U><S(S),1*U(1*U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: a) (w1 :: [a]) (w2 :: GHC.Types.Int) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 case Main.$winsertAt @ a w w1 ww1 of ww2 { (#,#) ww3 ww4 ->
                 GHC.Types.: @ a ww3 ww4 } }) -}
6e28cae4088a54ddb52ed0adf1c00e03
  isPalindrome :: GHC.Classes.Eq a => [a] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (xs :: [a]) ->
                 GHC.Classes.$fEq[]_$c== @ a $dEq xs (Main.myReverse @ a xs)) -}
69e70e6fe7475a1157c55d2493ba15be
  main :: GHC.Types.IO ()
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
e8830693d91f71da8037bb39d10947e7
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Unfolding: (Main.main2 Main.solve) -}
0613c804b4ef10447b826a18bd6034d6
  main2 ::
    (GHC.Base.String -> GHC.Base.String)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,C(U)><S,U>,
     Unfolding: (\ (f :: GHC.Base.String -> GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.Internals.wantReadableHandle_1
                        @ GHC.Base.String
                        GHC.IO.Handle.Text.hGetLine4
                        GHC.IO.Handle.FD.stdin
                        GHC.IO.Handle.Text.hGetLine2
                          `cast`
                        (<GHC.IO.Handle.Types.Handle__>_R
                         ->_R Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R))
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case Text.Read.readEither6
                        @ GHC.Types.Int
                        (Text.ParserCombinators.ReadP.run
                           @ GHC.Types.Int
                           Main.main5
                           ipv1) of wild {
                   []
                   -> case Main.main4
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                      of {}
                   : x ds
                   -> case ds of wild1 {
                        []
                        -> case x of ww { GHC.Types.I# ww1 ->
                           Main.$wprintResults f ww1 ipv }
                        : ipv2 ipv3
                        -> case Main.main3
                           ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                           of {} } } }) -}
649af1f590f20baad89400f56adf6243
  main3 :: GHC.Types.Int
  {- Strictness: x -}
2f36c646821e3517047298cbab184af1
  main4 :: GHC.Types.Int
  {- Strictness: x -}
ba0ffbbbcb305d67afb98a0bba2d6d7e
  main5 :: Text.ParserCombinators.ReadP.P GHC.Types.Int
  {- Unfolding: (GHC.Read.$fReadInt3
                   GHC.Read.$fReadInt_$sconvertInt
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Types.Int
                   (Text.Read.readEither5 @ GHC.Types.Int)) -}
7ecbf00bb0f859f735b1f207fb7a0348
  main6 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
7ba5e59071a117c47c3e848e8306ace5
  myButLast :: [a] -> a
  {- Arity: 1, Strictness: <S,1*U> -}
0dc6c3691f19479cf76f1b796bac2010
  myFlatten :: Main.NestedList a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
11427b5c7e3af43c1354fc3830337e12
  myLast :: [a] -> a
  {- Arity: 1, Strictness: <S,1*U> -}
7da0798bb732250fd40215bc26a9525e
  myLength :: [a] -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: [a]) ->
                 case Main.$wmyLength @ a w of ww { DEFAULT -> GHC.Types.I# ww }) -}
001c2ba98862c1774ac0b58cd05b4b16
  myReverse :: [a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
0fdb9477df3e80c56d04e0405094bc28
  pack :: GHC.Classes.Eq a => [a] -> [[a]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><S,1*U> -}
bb734537cb15c92a33a7a5c7d3fa71c6
  printResults ::
    (GHC.Base.String -> GHC.Base.String)
    -> GHC.Types.Int -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,C(U)><S(S),1*U(1*U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.printResults1
                  `cast`
                (<GHC.Base.String -> GHC.Base.String>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
ec57c870fbe635156d0eee7a4a84d9c8
  printResults1 ::
    (GHC.Base.String -> GHC.Base.String)
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,C(U)><S(S),1*U(1*U)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Base.String -> GHC.Base.String)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Main.$wprintResults w ww1 w2 }) -}
0489309f3ae3259d19c86dcc7323bef6
  range :: GHC.Types.Int -> GHC.Types.Int -> [GHC.Types.Int]
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 case Main.$wrange ww1 ww3 of ww4 { (#,#) ww5 ww6 ->
                 GHC.Types.: @ GHC.Types.Int ww5 ww6 } } }) -}
55c6e8d7a7d4dae3a16e19a4dbadf13b
  remove :: [a] -> GHC.Types.Int -> (GHC.Base.Maybe a, [a])
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: [a]) (w1 :: GHC.Types.Int) ->
                 case Main.$wremove @ a w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
8e74025e5391f2cfb282bbf8cb5bfad5
  repli :: GHC.Types.Int -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,1*U>,
     Unfolding: (\ @ a (c :: GHC.Types.Int) (xs :: [a]) ->
                 letrec {
                   go :: [a] -> [a] {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [a]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ a
                       : y ys
                       -> case c of wild1 { GHC.Types.I# y1 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# 0# y1) of wild2 {
                            GHC.Types.False -> GHC.Base.++ @ a (GHC.Types.[] @ a) (go ys)
                            GHC.Types.True
                            -> let {
                                 lvl36 :: [a] = GHC.Types.: @ a y (GHC.Types.[] @ a)
                               } in
                               letrec {
                                 $wxs :: GHC.Prim.Int# -> [a]
                                   {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                                 = \ (ww :: GHC.Prim.Int#) ->
                                   case ww of ds1 {
                                     DEFAULT -> GHC.Types.: @ a y ($wxs (GHC.Prim.-# ds1 1#))
                                     1# -> lvl36 }
                               } in
                               GHC.Base.++ @ a ($wxs y1) (go ys) } } }
                 } in
                 go xs) -}
856c5f301a4691c7c12f49be58bd8010
  rndElem :: [a] -> GHC.Types.IO a
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.rndElem1
                  `cast`
                (forall (a :: <*>_N).
                 <[a]>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)) -}
0c427ed46525430260c76e5b90fc0292
  rndElem1 ::
    [a]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ @ a
                   (xs :: [a])
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case System.Random.$fRandomInt3
                        (Main.$fShowExt1,
                         case GHC.List.$wlenAcc @ a xs 0# of ww2 { DEFAULT ->
                         GHC.Types.I# (GHC.Prim.-# ww2 1#) })
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.List.!! @ a xs ipv1 #) }) -}
6c11d31fce0bcc5d1f8bd23d52e41def
  rndPermutation :: [a] -> GHC.Types.IO [a]
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.rndPermutation1
                  `cast`
                (forall (a :: <*>_N).
                 <[a]>_R ->_R Sym (GHC.Types.N:IO[0] <[a]>_R)) -}
0026e38c648c54596719abe6d0c3f9f2
  rndPermutation1 ::
    [a]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a] #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (x :: [a])
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 Main.rndElem1 @ [a] (Data.OldList.permutations @ a x) eta) -}
e1aad3339a03f79ad4fd97ea8a78a414
  rnd_select :: [a] -> GHC.Types.Int -> GHC.Types.IO [a]
  {- Arity: 3, Strictness: <L,U><L,1*U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.rnd_select1
                  `cast`
                (forall (a :: <*>_N).
                 <[a]>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[a]>_R)) -}
a2ec7b546cbaf3448c6f736bf87ed8cc
  rnd_select1 ::
    [a]
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a] #)
  {- Arity: 3, Strictness: <L,U><L,1*U(U)><S,U>,
     Unfolding: (\ @ a
                   (xs :: [a])
                   (n :: GHC.Types.Int)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case System.Random.theStdGen
                        `cast`
                      (GHC.IORef.N:IORef[0] <System.Random.StdGen>_N) of wild { GHC.STRef.STRef var# ->
                 case GHC.Prim.readMutVar#
                        @ GHC.Prim.RealWorld
                        @ System.Random.StdGen
                        var#
                        eta of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    case n of wild1 { GHC.Types.I# y ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<# 0# y) of wild2 {
                      GHC.Types.False -> GHC.Types.[] @ a
                      GHC.Types.True
                      -> case GHC.List.$wlenAcc @ a xs 0# of ww2 { DEFAULT ->
                         let {
                           w1 :: GHC.Integer.Type.Integer
                           = GHC.Integer.Type.smallInteger (GHC.Prim.-# ww2 1#)
                         } in
                         letrec {
                           $wgo :: System.Random.StdGen -> GHC.Prim.Int# -> [a]
                             {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
                           = \ (w :: System.Random.StdGen) (ww :: GHC.Prim.Int#) ->
                             case System.Random.$wrandomIvalInteger
                                    @ System.Random.StdGen
                                    @ GHC.Types.Int
                                    System.Random.$fRandomGenStdGen
                                    GHC.Num.$fNumInt
                                    Main.rnd_select2
                                    w1
                                    w of ww1 { (#,#) ww3 ww4 ->
                             case ww3 of x1 { GHC.Types.I# ipv2 ->
                             case ww of ds2 {
                               DEFAULT
                               -> GHC.Types.:
                                    @ a
                                    (GHC.List.$w!! @ a xs ipv2)
                                    ($wgo ww4 (GHC.Prim.-# ds2 1#))
                               1#
                               -> GHC.Types.:
                                    @ a
                                    (GHC.List.$w!! @ a xs ipv2)
                                    (GHC.Types.[] @ a) } } }
                         } in
                         $wgo ipv1 y } } } #) } }) -}
e0dde05d2474973d2f0036080f4b1b3e
  rnd_select2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
f5f7d0f9130cfd1403f00d0556e10180
  rnd_select_i ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO [GHC.Types.Int]
  {- Arity: 2, Strictness: <L,U(U)><L,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                Main.rnd_select_i1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[GHC.Types.Int]>_R)) -}
cec18fca29d46b54c6dde734327baf93
  rnd_select_i1 ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Types.Int] #)
  {- Arity: 2, Strictness: <L,U(U)><L,1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (n :: GHC.Types.Int) (m :: GHC.Types.Int) ->
                 Main.rnd_select1
                   @ GHC.Types.Int
                   (case m of wild1 { GHC.Types.I# y ->
                    GHC.Base.build
                      @ GHC.Types.Int
                      (\ @ b
                         (c :: GHC.Types.Int -> b -> b)[OneShot]
                         (n1 :: b)[OneShot] ->
                       GHC.Enum.eftIntFB @ b c n1 1# y) })
                   n) -}
54155181dd8b218fbffbb999ee025539
  rotate :: [a] -> GHC.Types.Int -> [a]
  {- Arity: 2, Strictness: <S,1*U><L,1*U(1*U)> -}
8a55259f9a7105180f728cc6874a0a25
  solve :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Base.String) ->
                 case Main.$wsolve w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ GHC.Types.Char ww1 ww2 }) -}
23ca03118fd102299c8aec19b978d0fb
  solve1 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
9eea4fe4ab1598c0099621300f68fd2c
  solve2 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
87d47b3b95db5e34a43f93122ee80b25
  solve3 :: Text.ParserCombinators.ReadP.P GHC.Integer.Type.Integer
  {- Unfolding: (GHC.Read.$fReadInteger3
                   GHC.Read.$fReadInteger_$sconvertInt
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Integer.Type.Integer
                   (Text.Read.readEither5 @ GHC.Integer.Type.Integer)) -}
ff5b805ed9a7443862947a618981cdaa
  solveWithCounter ::
    (GHC.Base.String -> GHC.Base.String) -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,C(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main2
                  `cast`
                (<GHC.Base.String -> GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
74f5e4996bc735232a2cd3192fe1f276
  split :: [a] -> GHC.Types.Int -> ([a], [a])
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)>m,
     Unfolding: InlineRule (2, True, True) Main.split1 -}
157e09dd1edc0edb57e91e0faf73725e
  split1 :: [a] -> GHC.Types.Int -> ([a], [a])
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: [a]) (w1 :: GHC.Types.Int) ->
                 case Main.$wpoly_helper @ a w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
instance [safe] GHC.Show.Show [Main.Ext] = Main.$fShowExt
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

